---
title: "Taxonomy of Visualization Tools"
author: "Todd R. Johnson"
format:
  revealjs:
    # load custom JS globally
    include-in-header: makeGlossary.js
html-math-method: mathjax
editor: visual
---

## Interactive Glossary with makeGlossary
### Click a term to see its definition

<div id="gloss1"></div>

<script>
makeGlossary("gloss1", [
  { term: "Term 1", definition: "Definition of Term 1" },
  { term: "Term 2", definition: "Definition of Term 2" },
  { term: "Term 3", definition: "Definition of Term 3" }
]);
</script>

## Interactive Glossary
### Click a term to see its definition

:::: {.columns}
::: {.column width="30%"}

<ul id="terms">
  <li class="active" onclick="showDef('def1', this)">Term 1</li>
  <li onclick="showDef('def2', this)">Term 2</li>
  <li onclick="showDef('def3', this)">Term 3</li>
</ul>

<style>
  #terms li {
    cursor: pointer;
    padding: 4px;
  }
  #terms li.active {
    font-weight: bold;
    color: #007acc; /* highlight color */
  }
</style>

:::

::: {.column width="70%"}
<div id="definitions">
  <div id="def1" class="definition" style="display:block;">Definition of Term 1</div>
  <div id="def2" class="definition" style="display:none;">Definition of Term 2</div>
  <div id="def3" class="definition" style="display:none;">Definition of Term 3</div>
</div>
:::
::::

<script>
function showDef(id, el) {
  // hide all definitions
  document.querySelectorAll('#definitions .definition')
    .forEach(def => def.style.display = 'none');
  // show selected one
  document.getElementById(id).style.display = 'block';

  // remove highlight from all terms
  document.querySelectorAll('#terms li')
    .forEach(li => li.classList.remove('active'));
  // highlight clicked term
  el.classList.add('active');
}
</script>

## Key Concepts

<style>
/* Initially hide all definition divs */
.definition {
  display: none;
}
</style>


:::{.columns}

:::{.column width="40%"}
*   <a href="#" onclick="showDefinition(event, 'term1-def');">**Term 1**</a>
*   <a href="#" onclick="showDefinition(event, 'term2-def');">**Term 2**</a>
*   <a href="#" onclick="showDefinition(event, 'term3-def');">**Term 3**</a>
:::

:::{.column width="60%"}
<div id="term1-def" class="definition">
### Definition for Term 1
This is the full explanation for the first term.
</div>

<div id="term2-def" class="definition">
### Definition for Term 2
This is the definition for the second term. It can contain multiple paragraphs and other markdown content.
</div>

<div id="term3-def" class="definition">
### Definition for Term 3
Here is the definition for the final term. You can style the definition blocks further with custom CSS.
</div>
:::

:::

<script>
function showDefinition(event, id) {
  // Prevent the default action of the anchor link
  event.preventDefault();
  
  // Hide all definitions
  const allDefinitions = document.querySelectorAll('.definition');
  allDefinitions.forEach(el => {
    el.style.display = 'none';
  });
  
  // Show the selected definition
  const selectedDef = document.getElementById(id);
  if (selectedDef) {
    selectedDef.style.display = 'block';
  }
}
</script>


## Glossary Terms
::: columns
::: {.column width="40%"}
### Terms
- [Term 1](#)
- [Term 2](#)
- [Term 3](#)
:::

::: {.column width="60%"}
### Definitions

::: {.fragment}
**Term 1:** The definition for the first term appears here.
:::

::: {.fragment}
**Term 2:** The definition for the second term appears here.
:::

::: {.fragment}
**Term 3:** The definition for the third term appears here.
:::
:::
:::

## Visualization Tool Dimensions {.scrollable}

:::: {.smaller}

-   **Abstraction Level**

    -   How much of the visualization pipeline is handled automatically

-   **Expressiveness**

    -   The range of visual designs and customizations possible within the tool's constraints

-   **Ease of Use**

    -   How quickly users can become productive and create visualizations without extensive training

-   **Interaction Capabilities**

    -   The sophistication of cross-chart filtering, linking, and dynamic behaviors supported

-   **Data Abstraction**

    -   The tool's ability to connect to and work with diverse data sources without manual preprocessing

-   **Reusability**

    -   How easily visualization logic can be applied to new datasets or replicated across contexts

-   **Interface Paradigm**

    -   Whether users specify visualizations through code/markup (declarative) or point-and-click interfaces (GUI)

-   **Theoretical Foundation**

    -   Whether the tool is based on formal visualization theories and systematic frameworks versus pragmatic collections of chart types
    
::::    
    

## Types of Visualization Tools

-   Chart Libraries (Typologies)

    -   Excel, Google Sheets, Power BI, Plotly Express

-   Visual Analysis Grammars

    -   Tableau, ggplot2, Altair, Vega-Lite

-   Visualization Grammars

    -   Protovis, D3,js

-   Component Architectures

    -   Prefuse, Flare, VTK

-   Graphics APIs

    -   Processing, OpenGL, Java2D

## Next slide

```{r}
library(reticulate)
py_require("altair")
alt = import("altair")

py_require("vega_datasets")
vd = import("vega_datasets")
 
```

Looks like it is better to author the processing example in jupyter notebook and then include it in this document while embedding the code as follows in the Embedding Code part of this page: https://quarto.org/docs/authoring/notebook-embed.html with {{< embed penguins.ipynb#species-counts echo=true >}}

## Embed html iframe

```{=html}
<iframe width="780" height="500" src="./Processing-iris_scatterplot.html" title="Quarto Documentation"></iframe>
```

## Graphics API: Processing

![](./Processing-iris_scatterplot.html){width="100%" height="600px"}

## Grammar of Graphics

![](https://github.com/QCBSRworkshops/workshop03/blob/main/pres-en/images/ggplot-grammar-of-graphics-stack-1.png?raw=true)

## Altair

```{python}
#| output-location: column
#| results: hold
#| echo: true
#| title: Iowa Electricity
import altair as alt
from vega_datasets import data
source = data.iowa_electricity()
alt.Chart(source).mark_area(opacity=0.3).encode(
  x="year:T",
  y=alt.Y("net_generation:Q").stack(None),
  color="source:N"
)
```

## Data

Graphics start with data

```{r}
#| echo: true
#| results: hold
# Load required libraries and data
library(ggplot2)
library(dplyr)
library(openxlsx)
library(flextable)

# Load data from an Excel spreadsheet
data <- read.xlsx("./healthcare cost data.xlsx")

# View the data
flextable(head(data))


```

## Aesthetics

## Mapping

How to map *data* onto *aesthetic* attributes of *geometric* objects

```{r}
#| echo: true
#| results: hold
ggplot(data, aes(x = Patient.Count, y = Total.Cost))
```

## Layers

-   A graph is made of one or more layers
-   Each layer has three parts:
    -   *Geometry* determines *how* data are displayed (points, lines, etc.)
    -   *Statistical transformations* affect *what* is displayed

## Geometries

Describe geometries

## Geometries: Point {auto-animate="true"}

```{r}
#| echo: true
#| results: hold
#| code-line-numbers: "2"
ggplot(data, aes(x = Age, y = Total.Cost)) +
  geom_point()
```

## Geometries: Point, colored by Disease {auto-animate="true"}

```{r}
#| echo: true
#| results: hold
#| code-line-numbers: "2"
ggplot(data, aes(x = Age, y = Total.Cost)) +
  geom_point(aes(color = Disease))
```

## Geometries: Line, colored by Disease {auto-animate="true"}

```{r}
#| echo: true
#| results: hold
#| code-line-numbers: "2"
ggplot(data, aes(x = Age, y = Total.Cost)) +
  geom_line(aes(color = Disease))
```

## Geometries: Line + Point {auto-animate="true"}

```{r}
#| echo: true
#| results: hold
#| code-line-numbers: "2-3"
ggplot(data, aes(x = Age, y = Total.Cost)) +
  geom_line(aes(color = Disease)) +
  geom_point(aes(color = Disease))
```

## Scales {auto-animate="true"}

Scales map data values to aesthetic values. Here we change the default color scale used for Disease

```{r}
#| echo: true
#| results: hold
#| code-line-numbers: "4"
ggplot(data, aes(x = Age, y = Total.Cost)) +
  geom_line(aes(color = Disease)) +
  geom_point(aes(color = Disease)) +
  scale_color_viridis_d()
```

## Facets {auto-animate="true"}

```{r}
#| echo: true
#| results: hold
#| code-line-numbers: "2-3"
ggplot(data, aes(x = Age, y = Total.Cost)) +
  geom_line(aes(color = Disease)) +
  facet_wrap(~ Disease) 
```

## Facets (without color coding) {auto-animate="true"}

```{r}
#| echo: true
#| results: hold
#| code-line-numbers: "2-4"
ggplot(data, aes(x = Age, y = Total.Cost)) +
  geom_line() +
  facet_wrap(~ Disease) 
```

## Statistics {auto-animate="true"}

```{r}
#| echo: true
#| results: hold
#| code-line-numbers: "2-4"
ggplot(data, aes(x = Age, y = Total.Cost)) +
  geom_point(aes(color=Disease)) +
  geom_line(aes(color=Disease)) +
  stat_summary(geom="line", fun="mean")
```

## Coordinates

```{r}
#| echo: true
#| results: hold
#| code-line-numbers: "4"
ggplot(data, aes(x = Age, y = Total.Cost)) +
  geom_point(aes(color=Disease)) +
  geom_line(aes(color=Disease)) +
  stat_summary(geom="line", fun="mean")
```

## Bullets

When you click the **Render** button a document will be generated that includes:

-   Content authored with markdown
-   Output from executable code

## Code

When you click the **Render** button a presentation will be generated that includes both content and the output of embedded code. $x_1 = 10$ You can embed code like this:

```{r}
1 + 1
```
